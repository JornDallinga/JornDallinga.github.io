---
title: "Proba-V"
author: "Jorn D"
date: "05-8-2016"
Version: "0.3 (updated 7-9)"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


```{r}
getwd()
```


## Preperation

This script has been tested and runs on a LINUX Centos machine, but might require some tweaking if used on other OS or versions. 

System on which the script has been tested:
```{r, echo=F, results= 'hold'}
Sys.info()['sysname']
.Platform$OS.type
version$os ## or R.version$os
```


The data used within these scripts can be downloaded from http://proba-v.vgt.vito.be/ website. Lets start with loading the required libaries and packages to illustrate a workflow on working with the PROBA-V data.

```{r, message=F, warning=F}
# add additional libary path
.libPaths( c( .libPaths(), "~/R/x86_64-redhat-linux-gnu-library/3.2") )

## libaries
library(ranger)
library(raster)
library(ggvis)
library(rgdal)
library(dplyr)
library(devtools)
library(gdalUtils)
library(probaV)
library(tools)
library(parallel)
library(knitr)
library(zoo)

```



```{r, echo=F}
# set the knitR working directory to the same file location as getwd(), in order to maintain the link to R source scripts.
knitr::opts_knit$set(root.dir = "/home/pi/PROBA_V/ProbaV_JD")

```

```{r, message=F, warning=F}
# below the fixed link file in order to load the ProbaV package from Johannes
source("R/processProbaVbatch2.R")
source("R/getHarmMetricsSpatial_JE.R")
source("R/mapDistance2Loess2.R")
source("R/CleanProbaV2.R")
source("R/timeVrtProbaV2.R")

```

## Data download

Lets download some data! Below an example on how to download the PROBA-V tiles by using coordinates. 

```{r}

# Select the location for which you wish to download the PROBA-V  tiles for. 
x <- 10.00
y <- 8.00

# In order to download the correct tile numbers, we use coordinates to convert to the tile number
tile <- probaVTileFromCoords(x, y)
tile_str <- paste("\'*",tile,"*\'", sep ="")

```

```{r, results='hide'}

# To download data from the PROBA-V vito website, we need to be a registerd user (free). We need the username and password, which you can enter below.
u_name <- readline("Type the username:")
p_word <- readline("Type the password:")


```


```{r}
# enter download location:
dirloc <- paste(getwd(), '/2015/', sep = "")

# Use wget to download the data. wget has be used directly in the terminal. Therefore, we pass the string to the system command.
wget_string <- paste('wget -A ', tile_str ,' -P ', dirloc, ' -r --user=', u_name,' --password=', p_word, ' http://www.vito-eodata.be/PDF/datapool/Free_Data/PROBA-V_300m/S1_TOC_-_300_m/2015/7/13/PV_S1_TOC-20150713_333M_V001/?mode=tif', sep="")

print(wget_string)

```


```{r, eval=FALSE}

# pass the string to the terminal directly from R.
system(wget_string)

```

## Preprocessing

---- check  downloaded data
Only GeoTIFF is accepted
The files should be stored in the folder structure used by vito
(One foler per date contains files for all tiles).


```{r, echo=F}

# set your data path
l0_dir <- "/DATA/GEOTIFF/PROBAV_L3_S5_TOC_100M"
```

start by setting our data path which contains the downloaded files

```{r, eval=F}
# variable setting for data path
10_dir <- "set data path" 
# if you manually downloaded the data
10_dir <- dirloc

```

The following function searches through the downloaded data folder and retrieves the product information, such as tiles and acquisition dates. Since the following functions only work on .tif files, we add '.tif$' to the pattern selection.
```{r}
df_probav_down <- getProbaVinfo(l0_dir, pattern = ".tif$")

# plot the retrieved data
df_probav_down %>% ggvis(x=~tile, fill=~band) %>% layer_bars()
```

## clean data 
The function 'getProbaVQClist' creates a dataframe of state mask (SM) codes based on the quality indicators in the Status Map dataset. It provides an overview of clear codes per channel. 
```{r}
# Top of dataframe showing SM codes. 
head(getProbaVQClist()$all_bits)
# For clear pixel selection, we use the SM codes with 'clear_all', which means that a certain pixel is not marked as shadow, cloud, ice or sea. Additionally, it selects only the 'good' quality pixels of the radiometric bands (SWIR, NIR, RED, BLUE).
QC_val <- getProbaVQClist()$clear_all

# The QC_variable now stores the high quality value:
QC_val
```

Lets split the radiometry .tif into single layers (SWIR, NIR, RED, BLUE)
```{r}
# First, select the radiometry .tif files from the download folder and which tiles to use
patterns <- c('RADIOMETRY.tif$') # "NDVI.tif$"
tiles <- c("X18Y02") #..., "X21Y06")
# or tiles <- tile

# Lets gather the information from the radiometry band using the variables assigned above. 
head(getProbaVinfo(l0_dir, pattern = patterns, tiles = tiles))

#How many radiometry bands do we have of the assigned tiles?
df_in <- getProbaVinfo(l0_dir, pattern = patterns, tiles = tiles)
nrow(df_in)
```


Next step is to keep the quality control values in the data which correspond to the QC_val as result of the 'getProbaVQClist' function. Lets test this on a single date/location. Select a RADIOMETRY.tif file from the downloaded data folder and assign it to a variable. 
```{r}
# Assign variable to the file.path
r <- "/DATA/GEOTIFF/PROBAV_L3_S5_TOC_100M/20151021/PROBAV_S5_TOC_20151021_100M_V001/PROBAV_S5_TOC_X18Y02_20151021_100M_V001_NDVI.tif"
# Assign a file.path (including filename) to which we will write the cleaned data.
filename <- "/home/pi/PROBA_V/ProbaV_JD/rsdata/probav/sm2/PROBAV_S5_TOC_X18Y02_20151021_100M_V001.tif"

cleanProbaV2(f_data = r, filename=filename, QC_val = QC_val, fill=255, datatype="FLT4S", as.is = F, overwrite = T)

```

```{r}
# The result is a cleaned raster dataset (right) with only the quality control value (QC_val) selected. 
par(mfrow = c(1, 2))
plot(raster(r))
plot(raster(filename))
```


## Proccessing a ProbaV bath
The processProbaVbatch function uses the cleanProbaV function on a whole 'batch' of data. The starting date parameter helps selecting at which starting point you wish clean the data. The function uses parallel processing, which is useful when the machine has multiple processors or/and cores. The processing time of the following functions thus depend on the process capacity of your machine. 
```{r, eval=F}
# How many cores do we have:
detectCores(all.tests = FALSE, logical = TRUE)

# similar for NDVI
processProbaVbatch2(l0_dir, 
                    pattern = patterns, tiles = tiles, start_d = "2015-10-25",
                    QC_val = QC_val, outdir = file.path(paste0(getwd(),"/rsdata/probav/sm2", collapse ="")),
                    ncores = (detectCores(all.tests = FALSE, logical = TRUE)-1),
                    overwrite=F)


```

## Input check for next functions
```{r}

# ----- cehck input --- #
tn <- 1
tiles <- c("X18Y02")
probav_sm_dir <- file.path(paste0(getwd(),"/rsdata/probav/sm2/", collapse =""))
df_probav_sm <- getProbaVinfo(probav_sm_dir, pattern =  '_sm.tif$', tiles = tiles[tn])
glimpse(df_probav_sm)

# ----- parameters ----#
bands <-  df_probav_sm[df_probav_sm$date == df_probav_sm$date[1], 'band']
dates <-  df_probav_sm[df_probav_sm$band == bands[1], 'date']
minrows = 15
mc.cores = detectCores(all.tests = FALSE, logical = TRUE)-1
#logfile <- paste0("~/PROBA_V/rsdata/lcafrica/logs/metrics_tmp_", tiles[tn], ".log")
logfile <- file.path(getwd(), paste0("rsdata/probav/logs/", tiles[tn], ".log"))

vrt_name <- file.path(getwd(), paste0("rsdata/probav/sm2/", tiles[tn], "_",paste0(bands, collapse = "_"), ".vrt"))
out_name <- file.path(getwd(), paste0("rsdata/probav/metrics/",tiles[tn],"_harm_lm2_loess_03_scaled.envi"))
#rasterOptions(maxmemory = 2e+08, chunksize = 2e+08, todisk = F, progress = "window",
#              tmpdir = file.path(paste0(getwd(),"/rsdata/probav/temp", collapse ="")))

rasterOptions(todisk = F, progress = "text",
              tmpdir = file.path(paste0(getwd(),"/rsdata/probav/temp", collapse ="")))


# --- buld a vrt ---#
#(its faster than raster stack!)
gdalinfo(version = T)
```

## Select bands
Band selection for the virtual raster stack
```{r}
## Select the bands to use in sequential functions
bands_select <- '(BLUE|SWIR|NDVI)' # e.g. '(BLUE|SWIR|NDVI)' or '(BLUE|SWIR)' or 'NDVI'
bands_select <- 'NDVI' # e.g. '(BLUE|SWIR|NDVI)' or '(BLUE|SWIR)' or 'NDVI'

bands_sel <- paste(bands_select,'_sm.tif$', sep = "")
```


## virtual stack
Create a virtual stack from selected bands
```{r}
 b_vrt <- timeVrtProbaV2(probav_sm_dir, pattern = bands_sel, vrt_name = vrt_name, tile = tiles, return_raster = T, start_date = "2014-02-10", end_date = "2015-10-26")
  df_probav_sm <- timeVrtProbaV2(probav_sm_dir, pattern = bands_sel, vrt_name = vrt_name, tile = tiles[tn], return_raster = F, start_date ="2014-02-10", end_date = "2015-10-26")

```

## set temp extent
```{r}
xmin <- 9.191336 
xmax <- 9.218927 
ymin <- 45.53769
ymax <- 45.55274 
e <- extent(c(xmin,xmax,ymin,ymax))

# crop to extent
cr <- crop(x = b_vrt, y = e)
b_vrt <- cr
plot(b_vrt)
```

## check layers, bands, blocks and cores

```{r}
# --- get metrics ---  #
cat(sprintf("\nlayers: %i  | bands: %s  | blocks: %i  | cores: %i\n",
            nrow(df_probav_sm), paste0(bands, collapse = " "),
            blockSize(b_vrt, minrows = minrows)$n, mc.cores))
```


## create time series using zoo
```{r}
# Select first pixel of our raster stack
z <- zoo(c(b_vrt[1]), getZ(b_vrt))

# use smoothloes to create time series
f <- smoothLoess(tsx = z, QC_good=NULL, dates=dates,thresholds=c(-80, Inf, -120, 120) , res_type=c("all"), span=0.3)
plot(f)
```

## get metrics from smoothloes cleaned data
```{r}
d <- getHarmMetrics(f$x,QC_good = f$QC_good ,dates = dates, sig = .95, order = 1)
d
```


## Run metrics with a raster output
```{r}
# No scale
b_metrics <- getHarmMetricsSpatial_JE(x = b_vrt, minrows = minrows, mc.cores = mc.cores, logfile=logfile,
                                      overwrite=T, span=0.3,
                                      cf_bands = c(1), thresholds=c(-80, Inf, -120, 120),
                                      filename = out_name, probav_sm_dir = probav_sm_dir, order = 1, datatype="INT2S")
```


## plot the metrics

```{r}
# metrics info
b_metrics

# band order
# names c("min", "max", "intercept", names(lmh$coefficients)[-1])
# 

# plotting metrics
plot(b_metrics)
```


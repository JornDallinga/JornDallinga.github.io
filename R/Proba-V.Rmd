---
title: "Proba-V"
author: "Jorn D"
date: "05-8-2016"
Version: "0.3 (updated 27-9)"
output: html_document
---


#![WUR logo](http://www.wageningenur.nl/upload/f9a0b5f2-15c5-4b84-9e14-20ef02f5e265_wur-logo.png)

```{r, echo=FALSE, message=FALSE}
library(knitr)
opts_chunk$set(fig.width=5, fig.align='center', fig.height=5, dpi=72)
```


```{r}
getwd()
```


## Preperation

This script has been tested and runs on a LINUX Centos machine, but might require some tweaking if used on other OS or versions. 

System on which the script has been tested:
```{r, echo=F, results= 'hold'}
Sys.info()['sysname']
.Platform$OS.type
version$os ## or R.version$os
```


The data used within these scripts can be downloaded from http://proba-v.vgt.vito.be/ website. Lets start with loading the required libaries and packages to illustrate a workflow on working with the PROBA-V data.

```{r, message=F, warning=F}
# add additional libary path
.libPaths( c( .libPaths(), "~/R/x86_64-redhat-linux-gnu-library/3.2") )

## libaries
library(ranger)
library(raster)
library(ggvis)
library(rgdal)
library(dplyr)
library(devtools)
library(gdalUtils)
library(probaV)
library(tools)
library(parallel)
library(zoo)

```



```{r, echo=F}
# set the knitR working directory to the same file location as getwd(), in order to maintain the link to R source scripts.
knitr::opts_knit$set(root.dir = "/home/pi/PROBA_V/ProbaV_JD")

```

```{r, message=F, warning=F}
# below the fixed link file in order to load the ProbaV package from Johannes
source("R/processProbaVbatch2.R")
source("R/getHarmMetricsSpatial_JE.R")
source("R/mapDistance2Loess2.R")
source("R/CleanProbaV2.R")
source("R/timeVrtProbaV2.R")
source("R/cloud_filter.R")

```

## Data download

Lets download some data! Below an example on how to download the PROBA-V tiles by using coordinates. 

```{r}

# Select the location for which you wish to download the PROBA-V  tiles for. 
x <- 10.00
y <- 8.00

# In order to download the correct tile numbers, we use coordinates to convert to the tile number
tile <- probaVTileFromCoords(x, y)
tile_str <- paste("\'*",tile,"*\'", sep ="")

```

```{r, results='hide'}

# To download data from the PROBA-V vito website, we need to be a registerd user (free). We need the username and password, which you can enter below.
u_name <- readline("Type the username:")
p_word <- readline("Type the password:")


```


```{r}
# enter download location:
dirloc <- paste(getwd(), '/2015/', sep = "")

# Use wget to download the data. wget has be used directly in the terminal. Therefore, we pass the string to the system command.
wget_string <- paste('wget -A ', tile_str ,' -P ', dirloc, ' -r --user=', u_name,' --password=', p_word, ' http://www.vito-eodata.be/PDF/datapool/Free_Data/PROBA-V_300m/S1_TOC_-_300_m/2015/7/13/PV_S1_TOC-20150713_333M_V001/?mode=tif', sep="")

print(wget_string)

```


```{r, eval=FALSE}

# pass the string to the terminal directly from R.
system(wget_string)

```

## Preprocessing

---- check  downloaded data
Only GeoTIFF is accepted
The files should be stored in the folder structure used by vito
(One foler per date contains files for all tiles).


```{r, echo=F}

# set your data path
l0_dir <- "/DATA/GEOTIFF/PROBAV_L3_S5_TOC_100M"
```

start by setting our data path which contains the downloaded files

```{r, eval=F}
# variable setting for data path
10_dir <- "set data path" 
# if you manually downloaded the data
10_dir <- dirloc

```

The following function searches through the downloaded data folder and retrieves the product information, such as tiles and acquisition dates. Since the following functions only work on .tif files, we add '.tif$' to the pattern selection.
```{r}
df_probav_down <- getProbaVinfo(l0_dir, pattern = ".tif$")

# plot the retrieved data
df_probav_down %>% ggvis(x=~tile, fill=~band) %>% layer_bars()
```

## clean data 
The function 'getProbaVQClist' creates a dataframe of state mask (SM) codes based on the quality indicators in the Status Map dataset. It provides an overview of clear codes per channel. 
```{r}
# Top of dataframe showing SM codes. 
head(getProbaVQClist()$all_bits)
# For clear pixel selection, we use the SM codes with 'clear_all', which means that a certain pixel is not marked as shadow, cloud, ice or sea. Additionally, it selects only the 'good' quality pixels of the radiometric bands (SWIR, NIR, RED, BLUE).
QC_val <- getProbaVQClist()$clear_all

# The QC_variable now stores the high quality value:
QC_val
```

Lets split the radiometry .tif into single layers (SWIR, NIR, RED, BLUE)
```{r}
# First, select the radiometry .tif files from the download folder and which tiles to use
patterns <- c('RADIOMETRY.tif$') # "NDVI.tif$"
tiles <- c("X18Y02") #..., "X21Y06")
# or tiles <- tile

# Lets gather the information from the radiometry band using the variables assigned above. 
head(getProbaVinfo(l0_dir, pattern = patterns, tiles = tiles))

#How many radiometry bands do we have of the assigned tiles?
df_in <- getProbaVinfo(l0_dir, pattern = patterns, tiles = tiles)
nrow(df_in)
```


Next step is to keep the quality control values in the data which correspond to the QC_val as result of the 'getProbaVQClist' function. Lets test this on a single date/location. Select a RADIOMETRY.tif file from the downloaded data folder and assign it to a variable. 
```{r}
# Assign variable to the file.path
r <- "/DATA/GEOTIFF/PROBAV_L3_S5_TOC_100M/20151021/PROBAV_S5_TOC_20151021_100M_V001/PROBAV_S5_TOC_X18Y02_20151021_100M_V001_NDVI.tif"
# Assign a file.path (including filename) to which we will write the cleaned data.
filename <- "/home/pi/PROBA_V/ProbaV_JD/rsdata/probav/sm2/PROBAV_S5_TOC_X18Y02_20151021_100M_V001.tif"

cleanProbaV2(f_data = r, filename=filename, QC_val = QC_val, fill=255, datatype="FLT4S", as.is = F, overwrite = T)

```

```{r}
# The result is a cleaned raster dataset (right) with only the quality control value (QC_val) selected. 
par(mfrow = c(1, 2))
plot(raster(r))
plot(raster(filename))
```


## Proccessing a ProbaV bath
The processProbaVbatch function uses the cleanProbaV function on a whole 'batch' of data. The starting date parameter helps selecting at which starting point you wish clean the data. The function uses parallel processing, which is useful when the machine has multiple processors or/and cores. The processing time of the following functions thus depend on the process capacity of your machine. 
```{r, eval=F}
# How many cores do we have:
detectCores(all.tests = FALSE, logical = TRUE)

# similar for NDVI
processProbaVbatch2(l0_dir, 
                    pattern = patterns, tiles = tiles, start_d = "2015-10-25",
                    QC_val = QC_val, outdir = file.path(paste0(getwd(),"/rsdata/probav/sm2", collapse ="")),
                    ncores = (detectCores(all.tests = FALSE, logical = TRUE)-1),
                    overwrite=F)


```

## Input check for next functions
```{r}

# ----- cehck input --- #
tn <- 1
tiles <- c("X18Y02")
probav_sm_dir <- file.path(paste0(getwd(),"/rsdata/probav/sm2/", collapse =""))
df_probav_sm <- getProbaVinfo(probav_sm_dir, pattern =  '_sm.tif$', tiles = tiles[tn])
glimpse(df_probav_sm)

# ----- parameters ----#
bands <-  df_probav_sm[df_probav_sm$date == df_probav_sm$date[1], 'band']
dates <-  df_probav_sm[df_probav_sm$band == bands[1], 'date']
minrows = 15
mc.cores = detectCores(all.tests = FALSE, logical = TRUE)-1
#logfile <- paste0("~/PROBA_V/rsdata/lcafrica/logs/metrics_tmp_", tiles[tn], ".log")
logfile <- file.path(getwd(), paste0("rsdata/probav/logs/", tiles[tn], ".log"))

vrt_name <- file.path(getwd(), paste0("rsdata/probav/sm2/", tiles[tn], "_",paste0(bands, collapse = "_"), ".vrt"))
out_name <- file.path(getwd(), paste0("rsdata/probav/metrics/",tiles[tn],"_harm_lm2_loess_03_scaled.envi"))
#rasterOptions(maxmemory = 2e+08, chunksize = 2e+08, todisk = F, progress = "window",
#              tmpdir = file.path(paste0(getwd(),"/rsdata/probav/temp", collapse ="")))

rasterOptions(todisk = F, progress = "text",
              tmpdir = file.path(paste0(getwd(),"/rsdata/probav/temp", collapse ="")))


# --- buld a vrt ---#
#(its faster than raster stack!)
gdalinfo(version = T)
```

## Select bands
Band selection for the virtual raster stack
```{r}
## Select the bands to use in sequential functions
bands_select <- '(BLUE|SWIR|NDVI)' # e.g. '(BLUE|SWIR|NDVI)' or '(BLUE|SWIR)' or 'NDVI'
bands_select <- 'NDVI' # e.g. '(BLUE|SWIR|NDVI)' or '(BLUE|SWIR)' or 'NDVI'

bands_sel <- paste(bands_select,'_sm.tif$', sep = "")
```


## virtual stack
Create a virtual stack from selected bands
```{r}
 b_vrt <- timeVrtProbaV2(probav_sm_dir, pattern = bands_sel, vrt_name = vrt_name, tile = tiles, return_raster = T, start_date = "2014-02-10", end_date = "2015-10-26")
  df_probav_sm <- timeVrtProbaV2(probav_sm_dir, pattern = bands_sel, vrt_name = vrt_name, tile = tiles[tn], return_raster = F, start_date ="2014-02-10", end_date = "2015-10-26")

```

## set temp extent
```{r}
xmin <- 9.191336 
xmax <- 9.218927 
ymin <- 45.53769
ymax <- 45.55274 
e <- extent(c(xmin,xmax,ymin,ymax))

# crop to extent
cr <- crop(x = b_vrt, y = e)
b_vrt <- cr
plot(b_vrt)
```


## cloudfilter example

```{r}
# Select all the bands for a false color image
bands_select <- '(BLUE|SWIR|NIR0|RED0)' 
bands_sel <- paste(bands_select,'_sm.tif$', sep = "")


# run process batch on unfiltered data
# Here we change the QC_value to select all the cells, including the cloud values.
# Write the clouds to a new directory, so it wont mess up the original file
# Select one point in time, lets say: 2015-04-16

cloud_dir <- "rsdata/probav/sm_Withclouds"
dir.create(file.path(cloud_dir), showWarnings = FALSE)

# select dir with clouds
probav_cloud_dir <- paste(getwd(),'/',cloud_dir, sep = "")
```
```{r, eval=F}
# we wont use NDVI for the cloud filter in this example, just the radiometry is needed
patterns <- c('RADIOMETRY.tif$')
processProbaVbatch2(l0_dir, 
                    pattern = patterns, tiles = tiles, start_date = "2015-04-16", end_date = "2015-04-16",
                    QC_val = 1:255, outdir = file.path(paste0(getwd(),cloud_dir, collapse ="")),
                    ncores = (detectCores(all.tests = FALSE, logical = TRUE)-1),
                    overwrite=F)

```
```{r}
# select dir with clouds
probav_cloud_dir <- paste(getwd(),'/',cloud_dir,'/', sep = "")
# load the image in our virtual raster stack
b_vrt <- timeVrtProbaV2(probav_cloud_dir, pattern = bands_sel, vrt_name = vrt_name, tile = tiles, return_raster = T, start_date = "2015-04-16", end_date = "2015-04-16")

# set extent
xmin <- 5.996773
xmax <- 6.468209
ymin <- 51.80702
ymax <- 52.43639 

# crop the images
e <- extent(c(xmin,xmax,ymin,ymax))
b_vrt_cloud <- crop(x = b_vrt, y = e)

# plot a false color image
plotRGB(b_vrt_cloud, 3, 2, 1, stretch='lin')
```

Visualize the cloud detection method inbedded in the Proba-V data.
```{r}
# cloud mask SM
bands_select <- '(BLUE|SWIR|NIR0)' 
bands_sel <- paste(bands_select,'_sm.tif$', sep = "")

# load the image in our virtual raster stack
b_vrt_cloud_mask <- timeVrtProbaV2(probav_sm_dir, pattern = bands_sel, vrt_name = vrt_name, tile = tiles, return_raster = T, start_date = "2015-04-16", end_date = "2015-04-16")
# crop image to previous determined extent
b_vrt_cloud_mask <- crop(x = b_vrt_cloud_mask, y = e)
# assign virtual raster stack to new variable
r <- b_vrt_cloud_mask
# copy data
r2 <- r
```

all NA values in our raster(r) are in this scene cloud pixels. We assign a value (9999) to these cloud pixels in order to visualize them against our cloud filter function later on. 
```{r}
r2[is.na(r)] <- 9999
r2[r2 < 9999] <- NA
# Lets plot the original cloud detection method inbedded within the ProbaV data.
r2 <- subset(r2,1)
plot(r2, col = 'red', legend = F)
```


Apply cloud filter. In this example we use the blue band.
```{r}
bands_select <- '(BLUE)' 
bands_sel <- paste(bands_select,'_sm.tif$', sep = "")
# Select all dates of the blue band
b_vrt <- timeVrtProbaV2(probav_sm_dir, pattern = bands_sel, vrt_name = vrt_name, tile = tiles, return_raster = T, start_date = "2014-03-06", end_date = "2015-12-06")
df_probav_sm <- timeVrtProbaV2(probav_sm_dir, pattern = bands_sel, vrt_name = vrt_name, tile = tiles[tn], return_raster = F, start_date = "2014-03-06", end_date = "2015-12-06")
out_name <- paste(getwd(),'/rsdata/probav/metrics/cloud_filter.envi', sep = "")
```
```{r, eval=F}
# set variables
# threshold for blue

blue_c_filter <- mcCalc(x=b_vrt, fun=cloud_filter, minrows = 15, mc.cores = mc.cores, logfile=logfile, out_name = out_name, overwrite = T, mc.preschedule = FALSE)
```


Lets select the same data as our false colour image from the raster brick we just created. 
```{r, eval=F}
# select date
blue_c_filter <- subset(blue_c_filter ,10)
# crop the subset to the same extent as our false colour image
blue_c_filter <- crop(x = blue_c_filter, y = e)
```

The cloud_filter function returns the Quality Control values. Meaning: "QC" is the status of observations: 0=Missing/band input QC, 1=good, 2=temporal outlier. Here we assign new values to our raster to viisualise what the SmoothLoes function detects by the extra clouds
```{r, eval=F}
# copy the data set
blue_c_filter_copy <- blue_c_filter
# assign values
blue_c_filter[blue_c_filter_copy != 2] <- NA 
blue_c_filter[blue_c_filter_copy == 2] <- 1
```
```{r, results='hide'}
blue_c_filter <- raster(paste(getwd(),'/rsdata/probav/cloudfilter/cloudfilter.tif', sep = ""))
```
```{r}
plot(blue_c_filter, col = 'darkred', legend = F)
```


Lets plots the original false colour again against the 2 cloud filters
```{r}
# data copy
r3 <- r2

r3[blue_c_filter == 1] <- 1
breakpoints <- c(0,2,9999)
colors <- c("darkred","red")
par(mfrow=c(1,3))
plotRGB(b_vrt_cloud, 3, 2, 1, stretch='lin')
plotRGB(b_vrt_cloud, 3, 2, 1, stretch='lin')
plot(r2, col = 'red', legend = F, add = T)
plotRGB(b_vrt_cloud, 3, 2, 1, stretch='lin')
plot(r3,breaks=breakpoints,col=colors, add = T, legend = F)
par(mfrow=c(1,1))
```


## check layers, bands, blocks and cores

```{r,eval=F}
# --- get metrics ---  #
cat(sprintf("\nlayers: %i  | bands: %s  | blocks: %i  | cores: %i\n",
            nrow(df_probav_sm), paste0(bands, collapse = " "),
            blockSize(b_vrt, minrows = minrows)$n, mc.cores))
```


## create time series using zoo
```{r,eval=F}
# Select first pixel of our raster stack
z <- zoo(c(b_vrt[1]), getZ(b_vrt))

# use smoothloes to create time series
f <- smoothLoess(tsx = z, QC_good=NULL, dates=dates,thresholds=c(-80, Inf, -120, 120) , res_type=c("all"), span=0.3)
plot(f)
```

## get metrics from smoothloes cleaned data
```{r,eval=F}
d <- getHarmMetrics(f$x,QC_good = f$QC_good ,dates = dates, sig = .95, order = 1)
d
```


## Run metrics with a raster output
```{r, eval=F}
# No scale
b_metrics <- getHarmMetricsSpatial_JE(x = b_vrt, minrows = minrows, mc.cores = mc.cores, logfile=logfile,
                                      overwrite=T, span=0.3,
                                      cf_bands = c(1), thresholds=c(-80, Inf, -120, 120),
                                      filename = out_name, probav_sm_dir = probav_sm_dir, order = 1, datatype="INT2S")
```


## plot the metrics

```{r,eval=F}
# metrics info
b_metrics

# band order
# names c("min", "max", "intercept", names(lmh$coefficients)[-1])
# 

# plotting metrics
plot(b_metrics)
```

